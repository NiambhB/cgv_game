<!DOCTYPE html>
<head>
<meta charset="UTF-8">
<title>_alpha_</title>
<script src="src\js\three.js"></script>
<script src="src\js\OrbitControls.js"></script>
<script src="src\js\libs\stats.min.js"></script>
<script src="src\js\OBJLoader.js"></script>
<script src="src\js\MTLLoader.js"></script>
<script src="src\js\threex.cubecamera.js"></script>
<script src="src\js\threex.atmospherematerial.js"></script>
<script src="src\js\threex.atmospherematerialdatgui.js"></script>
<script src="src\js\threex.dilategeometry.js"></script>
<script src="src\js\threex.geometricglowmesh.js"></script>
<script src="src\js\GeometryUtils.js"></script>
<script src="src\js\BendModifier.js"></script>


<script src ="src\level.js"></script>
<script src="src\alpha.js"></script>
<script src="src\map.js"></script>
<script src="src\menu.js"></script>
<script src="src\powerup.js"></script>
<script src="src\collectible.js"></script>

<script>

"use strict";

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< G L O B A L    V A R I A B L E S >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


var currLevel = 0; //level variable mostly for display purposes at the moment

var level = new Level(currLevel, 2000, 2000, 100, 20, 3, 																		// levelNum, width, depth, atmosphereHeight, alphaCameraDistance, startingLives, 
				2, ['models/tree/tree', 'models/mill/mill'],  "models/stork.js", "textures/floor.jpg",					// numRandomLights, buildingModelURLs, alphaModelURL, floorTextureURL,
				"textures/skyboxes/dawnmountain/", 3, 3, [0,1,2], 																// backgroundURL, numPowerups, numCollectibles, powerups, 
				1, -10, -2, -0.01);																														// alphaMaxSpeedY, alphaMinSpeedY, alphaMaxSpeedZ, alphaMinSpeedZ


/* General mechanics variables */
var canvas, renderer, scene, mainCamera; // Standard three.js requirements.
var container, stats;
var minimapCamera, minimapWidth = window.innerHeight/5, minimapHeight = window.innerHeight/5; //minimap variables
var controls;  // An OrbitControls object that is used to implement
               // rotation of the scene using the mouse.  (It actually rotates
               // the camera around the scene.)

/* flags for different instances */
var fullscreen = false;
var animating = false;  // Set to true when an animation is in progress.
var keys = []; //records current keys being pressed
var resetCameraFlag = false //flag to reset the camera position to original position
var alphaDone = false;
var mapDone = false;
var Score = 0;
var activePowerup = null;

/* Global object variables */
var player = new THREE.Object3D();
var alpha;	// player stats tracking + model  object
var worldMap; // make global so it can be accessed by collision function

/* Global object arrays */
var powerups = [];			// items providing certain powerups or "boosts" to the player for a short time when picked up
var collectibles = [];			// the items that the player needs to collect in order to progress to the next level
var menusArr = {};



/* Avi stuff */

var collideMeshArray = []; // array to store  all collidable mesh's (buildings + items)



var mixer = null;  // The object that animates the model, of type THREE.AnimationMixer


var mesh;

var joshSucks; // he does


/// TODO: Put these with global vars or somewhere else
var text = "JOSH  SUCKS",
	height = 0.5,
	size = 2,
	curveSegments = 4,
	font = undefined;
var group, textMesh1, textGeo, materials;




//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< I N I T I A L I S A T I O N   F U N C T I O N S >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
function createMenus(){
	var startMenu = new Menu(
			level.alphaCameraDistance * 2 * 2, 
			"textures/skyboxes/ulam/", 
			"sprites/buttons/", 
			["exit_button", "start_button"]
		);
	menusArr.startMenu = startMenu;
//	player.add(menusArr.startMenu.skybox);
/**	menusArr.push(startMenu);
	player.add(menusArr[0].skybox);
	for(var i = 0; i < menusArr[0].buttons.length; i++){
		player.add(menusArr[0].buttons[i]);
	}
*/
	var pauseMenu = new Menu(
			level.alphaCameraDistance * 2 * 2, 
			"textures/skyboxes/tantolunden5/", 
			"sprites/buttons/", 
			["exit_button", "restart_button", "resume_button"]
		);
		menusArr.pauseMenu = pauseMenu;
//	menusArr.push(pauseMenu);
}

/* /////////////////////////////////////////////////////////////
	Renders the camera given as input
	Called by render
	INPUT: camera to render, left and top are top left corner to start rendering from, width and height are size arguments of renderer
	OUTPUT: none
 *//////////////////////////////////////////////////////////////
function cameraRender( camera, left, top, width, height ){
	
	renderer.setViewport( left, top, width, height );
	renderer.setScissor( left, top, width, height );
	camera.updateProjectionMatrix();
    renderer.render(scene, camera);
}

/* /////////////////////////////////////////////////////////////
	Places object markers above given object on minimap
	Called by addMinimapObjects
	INPUT: objectArray is an array of objects to put objects above, item is what to place above the object
	OUTPUT: array of objects added to scene
 *//////////////////////////////////////////////////////////////
function putAboveObject(objectArray, item){
	var newItemArray = new Array();
	for (var i = 0; i < objectArray.length; i++){
		var currItem = item.clone();
		currItem.translateX(objectArray[i].position.x - currItem.position.x);
		currItem.translateZ(objectArray[i].position.z - currItem.position.z);
		currItem.translateY(level.atmosphereHeight * 2);
		scene.add(currItem);

		newItemArray.push(currItem);
	}
	return newItemArray;
}

/* /////////////////////////////////////////////////////////////
	Adds minimap objects to scene using putAboveObject
	Called by render
	INPUT: none
	OUTPUT: array of objects to be removed from the scene after the minimap view is rendered
 *//////////////////////////////////////////////////////////////
function addMinimapObjects(){
	var removeObjects = new Array();

	//add yellow sphere for player
	var alphaMarker = new THREE.Mesh(
		new THREE.SphereGeometry( 20 ),
		new THREE.MeshBasicMaterial( {color: 0xffff00} )	
	);
	removeObjects = removeObjects.concat(putAboveObject(new Array(player), alphaMarker));

	// add red cube for powerups
	var minimapPowerups = [];
	var powerupCube = new THREE.Mesh(
		new THREE.BoxGeometry( 20, 20, 20 ),
		new THREE.MeshBasicMaterial( {color: 0xff0000} )
	);
	removeObjects = removeObjects.concat(putAboveObject(powerups, powerupCube));

	//add blue dodecahedron for collectibles
	var minimapCollectibles = [];
	var collectibleDodec = new THREE.Mesh(
		new THREE.DodecahedronGeometry( 20 ),
		new THREE.MeshBasicMaterial( {color: 0x0000ff} )
	);
	removeObjects = removeObjects.concat(putAboveObject(collectibles, collectibleDodec));

	return removeObjects;
}


/* /////////////////////////////////////////////////////////////
	Removes given objects from the scene
	Called by render
	INPUT: array of objects to be removed
	OUTPUT: none
 *//////////////////////////////////////////////////////////////
function removeMinimapObjects( removeObjects ){
		for(var i = 0; i < removeObjects.length; i++){
			scene.remove(removeObjects[i]);
		}
}


/* /////////////////////////////////////////////////////////////
	The render function draws the scene.
	Called every frame and by init
	INPUT: none
	OUTPUT: none
 *//////////////////////////////////////////////////////////////
function render() {

	// Render main camera on entire screen
	cameraRender (mainCamera, 0, 0, window.innerWidth, window.innerHeight)	

	//if paused don't show minimap
	if(animating){
		scene.remove(worldMap.atmosphere);
		//add objects to minimap so it will be easier to see
		var removeObjects = addMinimapObjects();
		// Render minimap camera in top right corner
		cameraRender(minimapCamera, window.innerWidth - minimapWidth - 50, 20, minimapWidth, minimapHeight);
	
		// remove objects from minimap
		removeMinimapObjects(removeObjects);
		scene.add(worldMap.atmosphere)
	}
}

function createRandomLights(){
	for(var i = 0; i < level.numRandomLights; i++){
		var light = new THREE.PointLight(0xffffff, 1, 1000000);
		light.position.set(
			Math.pow(-1, Math.floor(Math.random() * 2) + 1) * level.worldWidth / (6 + Math.random() * 10),
			level.atmosphereHeight * (1 + Math.random()), 
			Math.pow(-1, Math.floor(Math.random() * 2) + 1) * level.worldWidth / (6 + Math.random() * 10)
		);

		//shadows for light 1
		light.castShadow = true;
		light.shadowDarkness = 0.5;
		//Set up shadow properties for the light
		light.shadow.mapSize.width = level.worldWidth;  
		light.shadow.mapSize.height = level.worldDepth; 
		light.shadow.camera.near = 0.5;    // default
		light.shadow.camera.far = Math.sqrt(Math.pow(level.atmosphereHeight,2) + Math.pow(Math.pow(level.worldWidth,2) + Math.pow(level.worldDepth,2),2));     // Pythagoras equation for edge to edge diagonal of livable map cube

		scene.add(light);
	}
}

function splitNumToParts(num, numParts){
	//split numBuildings between different models
	var numPerSplit = []; 
	var currNum = num;
	for(var i = 0; i < numParts -1; i++){
		var currAmount = Math.floor(Math.random() * currNum);
		numPerSplit.push(currAmount);
		currNum -= currAmount;
	}
	numPerSplit.push(currNum);

	return numPerSplit;
}

function createPowerups(){
	var powerupsSplit = splitNumToParts(level.numPowerups, powerupTypes.length);
	console.log("Powerups Split: " + powerupsSplit);

	
	for(var i = 0; i < powerupTypes.length; i++){
		for(var j = 0; j < powerupsSplit[i]; j++){
			powerups.push(new Powerup(i));
		}
	}
	// move powerups to random place on map
	randomMoveArray(powerups);

	for(var i = 0; i < powerups.length; i++){
		scene.add(powerups[i]);
	} 
}

function createCollectibles(){
	for(var i = 0; i < level.numCollectibles; i++){
		collectibles.push(new Collectible(
				new THREE.CylinderGeometry(1,0.5,1,32),
				new THREE.MeshPhongMaterial({color: 0xff00ff})
			)
		);
	}
	// move powerups to random place on map
	randomMoveArray(collectibles);

	for(var i = 0; i < collectibles.length; i++){
		scene.add(collectibles[i]);
	}
}

/* /////////////////////////////////////////////////////////////
	Creates the world map, lights, cameras, player and collectibles and powerups.
	Called by restartGame and init.
	INPUT: none
	OUTPUT: none
 *//////////////////////////////////////////////////////////////
function createWorld() {
    renderer.setClearColor("black"); // Background color for scene.
    scene = new THREE.Scene();
    scene.add(player);
    
	createMenus();
    // -------------------------------------- MAKE MAIN CAMERA -------------------------------------
    
    mainCamera = new THREE.PerspectiveCamera(
		30, 
		window.innerWidth/window.innerHeight, 
		0.1, 
		level.alphaCameraDistance * 20
	);
  mainCamera.position.z = level.alphaCameraDistance;
  player.add(mainCamera);

	//-------------------------------------------- LIGHTING ------------------------------------------------
	createRandomLights();
	var viewLight = new THREE.PointLight(0xff00ff, 1);
	player.add(viewLight);
	viewLight.position.z = level.alphaCameraDistance;
    
	//------------------------------------------ MINIMAP ----------------------------------------------
	minimapCamera = new THREE.OrthographicCamera(
	    window.innerHeight / -5,						// Left
		window.innerHeight / 5,							// Right
    	window.innerHeight / 5,							// Top
    	window.innerHeight / -5,						// Bottom
    	-3 * level.atmosphereHeight,					// Near 
    	10000 );           								// Far 
	minimapCamera.up = new THREE.Vector3(0,0,-1);
	minimapCamera.lookAt( new THREE.Vector3(0,-1,0) );

	scene.add(minimapCamera);


    //---------------------------------- CREATE THE WORLD -------------------------------------------
    


	worldMap = new Map(level.worldWidth, level.worldDepth, level.atmosphereHeight, level.floorTextureURL, level.backgroundURL, level.buildingModelURLs) //width, height, atmosphereHight, textureURL, skyboxDirectory

	scene.add(worldMap.floor);
	scene.background = worldMap.background;
	scene.add(worldMap.atmosphere);	

	//add buildings to scene
	worldMap.createBuildings(0.5); //map-buildings ratio is 1/2

	for (var i = 0; i < worldMap.buildings.length; i++){
		scene.add(worldMap.buildings[i]);
	}




	
	//---------------------------------- CUBE MAP OBJECT THING// TODO: DECIDE WHERE TO PUT THIS and CLEAN IT UP and TRY using NOT THREEx OR maybe keep it if Richard gives points for using extensions??--------------------------------------
	// try using https://threejs.org/examples/#webgl_materials_cubemap_dynamic2


	// resources: http://learningthreejs.com/blog/2014/05/12/live-cube-maps-reflections-in-your-three-dot-js-game-with-threex-dot-cubecamera/
	joshSucks = new THREE.Object3D();

	var geometry = new THREE.SphereGeometry(5, 32, 16);
	var material = new THREE.MeshPhongMaterial({
    color   : 'chrome',
	envMap 	: scene.background
	});
	mesh = new THREE.Mesh(geometry, material);
	//mesh.scale.set(5,10,10);
	mesh.position.set(0,0,0);	// centre obj coords of sphere
	scene.add(mesh);

	joshSucks.add(mesh);

	// GLOW THING
	// Source: https://github.com/jeromeetienne/threex.geometricglow
		

//////////////////////////////////////////////////////////////////////////////////
//		add  text	 														//
///	///////////////////////////////////////////////////////////////////////////////
	group = new THREE.Group();
	group.position.set(-8,0,10);	// obj translation of text object onto sphere. Currently doesn't reflect close objects nicely 

	//scene.add( group );
	loadFont();	// create the text object
	console.log("Loadfont was called");	
	joshSucks.add(group);
	joshSucks.position.set(3,3,-30);
	scene.add(joshSucks);



	//----------------------------------- CREATE THE PLAYER --------------------------------------------

// alpha is created by modelLoader function and added to player
	
	var loader = new THREE.JSONLoader();					// create loader for .js models

	loader.load(level.alphaModelURL, modelLoader);		// load model and call model_loader
	
	
//------------------------------------- CREATE POWERUPS -----------------------------------------------
	createPowerups();
//--------------------------------------- CREATE COLLECTIBLES ------------------------------------------------
	createCollectibles();
} // end function createWorld()


/*//////////////////////////////////////////////////////////////////////////
	Model Loader function for alpha object. Creates alpha, places it in the scene and sets up animation
	Callback function for JSON loader in createWorld
	INPUT: THREE geometry and material objects
	OUTPUT: none
///////////////////////////////////////////////////////////////////////////*/
function modelLoader(geometry, materials) {

	var material = new THREE.MeshLambertMaterial( {
        vertexColors: THREE.FaceColors,  	// use colors from the geometry
        morphTargets: true							// for animation
    });
    
	alpha = new Alpha(geometry,material, 1);	// create alpha object
	
// TRANSFORMS
	alpha.scale.set(0.05,0.05,0.05);
	alpha.position.set(0,0,0);
	alpha.rotateY(Math.PI);
	alpha.castShadow = true;
	player.add(alpha);				// add alpha to player
	player.translateY(10);			// move player so that alpha doesn't crash on game start

	alpha.geometry.computeBoundingBox();
	alphaDone = true;
	alpha.startup();

	
// ANIMATION STUFF
	mixer = new THREE.AnimationMixer( alpha );
	var clip = THREE.AnimationClip.CreateFromMorphTargetSequence( 'motion', geometry.morphTargets, 30 );
    var animationAction = mixer.clipAction(clip);
    animationAction.setDuration(1);
    animationAction.play(); 
	render();
}

// END OF INITIALISATION


/*<<<<<<<<<<<<<<<<<<<<<< C U S T O M 	S U B   R O U T I N E S >>>>>>>>>>>>>>>>>>>>>>>>>>>
			                                 |_
			                           _____|~ |____
			                          (  --         ~~~~--_,
			                           ~~~~~~~~~~~~~~~~~~~'`  

*/

/*///////////////////////////////////////////////////////////////////////////////// 
	Gets a random vector for a new position.
	Called by randomMoveArray
	INPUT: none
	OUTPUT: THREE.Vector3 with the new randomised position
//////////////////////////////////////////////////////////////////////////////////*/
function randomPlace(){
	var move = [];
	move.push(Math.pow(-1, Math.floor(Math.random() * 2 + 1)) * Math.random() * (worldMap.width / 2));
	move.push(Math.pow(-1, Math.floor(Math.random() * 2 + 1)) * Math.random() * worldMap.atmosphereHeight + 5);
	move.push(Math.pow(-1, Math.floor(Math.random() * 2 + 1)) * Math.random() * (worldMap.depth / 2));
	return new THREE.Vector3(move[0],move[1],move[2]);

}

/*///////////////////////////////////////////////////////////////////////////////// 
	For every object in the input array, calls randomPlace to get a new random position, places the object in that position, then finds a new position until it is no longer colliding with another object
	Called in createWorld for the collectibles and powerups
	INPUT: array of objects to place in random positions
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function randomMoveArray( arr ){
	for(var i = 0; i < arr.length; i++){
		var move = randomPlace();
		arr[i].position.set(move.x, move.y, move.z);
		arr[i].geometry.computeBoundingBox();
		while(buildingBoxCollision(arr[i]).length != 0){
			move = randomPlace();
			arr[i].position.set(move.x, move.y, move.z);
		}
	}
}


/*///////////////////////////////////////////////////////////////////////////////// 
	Reset the camera's to be behind the player (chase cam), after viewing the world.
	Called by 
	INPUT: none
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function resetCameraPosition(){
	var cameraRotationSpeed = 0.1;
	mainCamera.translateX((alpha.position.x - mainCamera.position.x) * cameraRotationSpeed);
	mainCamera.translateY((alpha.position.y - mainCamera.position.y) * cameraRotationSpeed);
	mainCamera.translateZ((alpha.position.z + level.alphaCameraDistance - mainCamera.position.z) * cameraRotationSpeed);
	mainCamera.lookAt(alpha.position);

	if(Math.abs(alpha.position.x - mainCamera.position.x) <= 0.01 &&
		Math.abs(alpha.position.y - mainCamera.position.y <= 0.01) &&
		Math.abs(alpha.position.z + level.alphaCameraDistance - mainCamera.position.z <= 0.01)){
		
		resetCameraFlag = false;
	}
}


//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< M E N U   F U N C T I O N S >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
/*///////////////////////////////////////////////////////////////////////////////// 
	Returns the current open menu
	Called by menuInteraction and keysPressed
	INPUT: none
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function openMenu(){
	var menu;
	if(menusArr.startMenu.isOpen){
		menu = menusArr.startMenu;
	} else {
		menu = menusArr.pauseMenu;
	}
	return menu;
}

/*///////////////////////////////////////////////////////////////////////////////// 
	Exits the menu.
	Called by exitMenu and menuInteraction
	INPUT: none
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function exitMenu(){
	var menu = openMenu();
	
	console.log("exiting menu");
	scene.remove(menu.skybox);
	for(var i = 0; i< menu.buttons.length; i++){
		scene.remove(menu.buttons[i]);
	}
	
	menu.isOpen = false;
	document.removeEventListener("mousedown", menuInteraction);
}


/*///////////////////////////////////////////////////////////////////////////////// 
	Uses raycasting to check which menu box the user clicks
	Callback function for mouseclick event listener in displayMenu
	INPUT: click event
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function menuInteraction(e){
	var raycaster = new THREE.Raycaster();
	var menu = openMenu();

	//var r = window.getBoundingClientRect();
	var x = e.clientX	// take in click coordinates
	var y = e.clientY	// 

	var a = 2 * x / window.innerWidth - 1; // convert canvas pixel coords to clip coords
	var b = 1 - 2 * y / window.innerHeight;

	raycaster.setFromCamera( new THREE.Vector2(a,b), mainCamera );

	var intersections = raycaster.intersectObjects( menu.buttons, true );
	if(intersections.length >= 1){
		if(intersections[0].object.name == "restart_button"){
			console.log("restarting game");
			exitMenu();
			restartGame();
		} else if(intersections[0].object.name == "start_button"){
			console.log("starting game");
			exitMenu();
			animating = true;
			requestAnimationFrame(doFrame);
		} else if (intersections[0].object.name == "resume_button"){
			console.log("resuming game");
			exitMenu();
			animating = true;
			requestAnimationFrame(doFrame);
		} else if(intersections[0].object.name == "exit_button"){
			window.alert("This is, sadly, a web game.\nIf you want to close it you are welcome to close this browser tab.\nJust know that it cannot be proven that exiting this game will not result in you being dead one month later\nYou have been warned");
		}
	}
}

/*////////////////////////////////////////////////////////////////////////////////
	Display pause menu, sets position of menu skybox and buttons and places them in the scene, makes an event listener for mouseclicks
	Called by keysPressed when the 'p' key is pressed
	INPUT: none
	OUTPUT: none
/////////////////////////////////////////////////////////////////////////////////*/
function displayMenu(menu){
	menu.isOpen = true;
	menu.skybox.position.x = player.position.x;
	menu.skybox.position.y = player.position.y;
	menu.skybox.position.z = player.position.z;
	scene.add(menu.skybox);

	for(var i = 0; i < menu.buttons.length; i++){

  menu.buttons[i].position.x = player.position.x + Math.pow(-1, Math.floor(Math.random() * 2 + 1)) * Math.random() * ((level.alphaCameraDistance * 2 - 5) / 2);
  menu.buttons[i].position.y = player.position.y +  Math.random() * ((level.alphaCameraDistance * 2 - 5) / 2);
  menu.buttons[i].position.z = player.position.z + Math.pow(-1, Math.floor(Math.random() * 2 + 1)) * Math.random() * ((level.alphaCameraDistance * 2 - 5) / 2);


		scene.add(menu.buttons[i]);
	}

	console.log("displaying menu...");

	document.addEventListener("mousedown", menuInteraction, false);
}

//END OF MENU FUNCTIONS


/*///////////////////////////////////////////////////////////////////////////////////
	Restart game - reset all alpha variables, reload all models, respawn alpha at origin
	Called by Crash when the player crashes and has no more lives, menuInteraction when the restart game option is chosen and collisions when all collectibles are found
	INPUT: none
	OUTPUT: none
////////////////////////////////////////////////////////////////////////////////////*/
function restartGame(){
	console.log("restarting game");
	level.reinitializeGlobals();
	createWorld();
	installOrbitControls();
	console.log("game restarted");	
}

/*//////////////////////////////////////////////////////////////////////////
	Reduce player Y speed for for gravity and make them crash if they touch the floor
	Called by updateForFrame every frame
	INPUT: none
	OUTPUT: returns false if the player crashes and true if they dont
///////////////////////////////////////////////////////////////////////////*/
function putOnFloor() {
	if(player.position.y > worldMap.floorHeight + alpha.getRadius() - 2) {	//check if player has reached the "floor" + some leeway
		alpha.incSpeedY(-0.01);																		//if they have not, reduce speed (gravity)
		return true;
	} else {						//if they have, the player crashes
		Crash();
		return false;
	}	
}


/*//////////////////////////////////////////////////////////////////////////
	Crash: Explosion, respawn from crash site, decrement lives, game over
	Called by colllisions, updateForFrame and putOnFloor
	INPUT: none
	OUTPUT: none
///////////////////////////////////////////////////////////////////////////*/
function Crash() {
	// Update Alpha stats
	alpha.lives -= 1;
	
	// if no more lives, game over
	if (alpha.lives == 0){
		animating = false;
		window.alert("G A M E    O V E R\nYour final score: " + Score + "\nClick OK to start a new game");
		restartGame();
		//do other stuff
	}else{
	// TODO : Crash animation, respawn
		console.log("alpha crashed...");
		animating = false;
		window.alert("C R A S H E D!\n Lives left: " + alpha.lives);
		alpha.respawn();
	}
}



//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< C O L L I S I O N S ! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


/*///////////////////////////////////////////////////////////////////////////////// 
	Check for collision between two bounding boxes. Note bounding boxes have min: x,y,z, and max: x,y,z values
	Called by buildingBoxCollision
	INPUT: two objects
	OUTPUT: returns true if their is a collision, false otherwise
//////////////////////////////////////////////////////////////////////////////////*/
function twoBoxCollision(box1, box2){
	if(
		(box1.max.x < box2.min.x || box1.min.x > box2.max.x) ||
		(box1.max.y < box2.min.y || box1.min.y > box2.max.y) ||
		(box1.max.z < box2.min.z || box1.min.z > box2.max.z) 
	){
		return false;
	}
	return true;
}


/*///////////////////////////////////////////////////////////////////////////////// 
	This function checks for collision of bounding boxes of alpha and the map buildings
	Called by collisions and randomMoveArray
	INPUT: object to check collision for
	OUTPUT: object array of suspected collisions with input objects
//////////////////////////////////////////////////////////////////////////////////*/
function buildingBoxCollision( object ){
	var suspectObjects = [];
	var objectBox = new THREE.Box3();
    objectBox.setFromObject( object );

	for(var i = 0; i < worldMap.buildingBoxes.length; i++){
		if(twoBoxCollision(worldMap.buildingBoxes[i], objectBox)){
			suspectObjects.push(worldMap.buildings[i]);
		}
	}
	return suspectObjects;
}


// credit to Lee Stemkoski for his tutorial
// insert link to page
/*///////////////////////////////////////////////////////////////////////////////// 
	Function to check for collisions between player and buildings, collectibles and powerups
	Called by updateForFrame and alpha.respawn
	INPUT: none
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function  collisions() {
	var originPoint = player.position.clone();	// players position
	var suspectObjects = buildingBoxCollision(alpha);

	for (var vertexIndex = 0; vertexIndex < alpha.geometry.vertices.length; vertexIndex++){		
		var localVertex = alpha.geometry.vertices[vertexIndex].clone();
		var globalVertex = localVertex.applyMatrix4( alpha.matrix );
		var directionVector = globalVertex.sub( alpha.position );
		
		var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
		
		// Check building collisions
		var BuildingCollisionResults = ray.intersectObjects( suspectObjects , true );
		
		// Check Powerups[] collisions
			// TODO
		var PowerupsCollisionResults = ray.intersectObjects(powerups);
		
		var CollectibleCollisionResults = ray.intersectObjects(collectibles);
		if ( 
			BuildingCollisionResults.length > 0 &&
			BuildingCollisionResults[0].distance < directionVector.length() - 1 &&
			!BuildingCollisionResults[0].point.equals(new THREE.Vector3(0,0,0))
		){ // TODO: adjust this offset (-1 currently)
			console.log("hit");
			Crash();
			break;
		}
		//TODO: if powerup 0,1,2 do stuff to alpha.stats, delete power up from powerupsarray,and remove from scene (maybe with a fancy animation)
		if (PowerupsCollisionResults.length > 0 && PowerupsCollisionResults[0].distance < directionVector.length()){
			//Check what type of powerup it was
			if(PowerupsCollisionResults[0].object.type == powerupTypes["gun"]){
				console.log("Gun"); //TODO: update alpha stats
			}else if(PowerupsCollisionResults[0].object.type == powerupTypes["invisible"]){
				console.log("Invisible"); //TODO: update alpha stats
			}else if(PowerupsCollisionResults[0].object.type == powerupTypes["gravity"]){
				console.log("Gravity"); //TODO: update alpha stats
			}
			
			PowerupsCollisionResults[0].object.activatePower();
			activePowerup = PowerupsCollisionResults[0].object;
			powerups.splice(powerups.indexOf (PowerupsCollisionResults[0].object), 1 );
			scene.remove(PowerupsCollisionResults[0].object);
		}
		
		if ( CollectibleCollisionResults.length > 0 && CollectibleCollisionResults[0].distance < directionVector.length() ){ 
			console.log(collectibles.indexOf (CollectibleCollisionResults[0].object) );
			collectibles.splice(collectibles.indexOf (CollectibleCollisionResults[0].object), 1 );
			scene.remove(CollectibleCollisionResults[0].object);
			
			if(collectibles.length == 0) {
				window.alert( "You won the level!");
				currLevel++;
				restartGame();
				return;
				//TODO: win the level if all collectibles collected
			}
		}

	}// end for loop	

} // end collision function

//END OF COLLISION FUNCTIONS


/*//////////////////////////////////////////////////////////////////////////
Fucking Text!
///////////////////////////////////////////////////////////////////////////*/


materials = [
	new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } ), // front
	new THREE.MeshPhongMaterial( { color: 0xffffff } ) // side
];
// get the font then run create text fn
function loadFont() {

	var loader = new THREE.FontLoader();
	loader.load( 'fonts/Etienne/helvetiker_regular.typeface.json', function ( response ) {

		font = response;
		createText();
		console.log("loadFont()");

	} );

}

// create text fn
function createText() {
	console.log("createText()");
	textGeo = new THREE.TextGeometry( text, {
		font: font,
		size: size,
		height: height,
		curveSegments: curveSegments
	});

	textGeo.computeBoundingBox();
	textGeo.computeVertexNormals();

	// "fix" side normals by removing z-component of normals for side faces
	// (this doesn't work well for beveled geometry as then we lose nice curvature around z-axis)
	var triangleAreaHeuristics = 0.1 * ( height * size );

	for ( var i = 0; i < textGeo.faces.length; i ++ ) {

		var face = textGeo.faces[ i ];

		if ( face.materialIndex == 1 ) {

			for ( var j = 0; j < face.vertexNormals.length; j ++ ) {

				face.vertexNormals[ j ].z = 0;
				face.vertexNormals[ j ].normalize();

			}

			var va = textGeo.vertices[ face.a ];
			var vb = textGeo.vertices[ face.b ];
			var vc = textGeo.vertices[ face.c ];

			var s = THREE.GeometryUtils.triangleArea( va, vb, vc );

			if ( s > triangleAreaHeuristics ) {

				for ( var j = 0; j < face.vertexNormals.length; j ++ ) {

					face.vertexNormals[ j ].copy( face.normal );

				}
			
			}

		}

	}

	var centerOffset = -0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

	textMesh1 = new THREE.Mesh( textGeo, materials );

	// bend the text - this took hours to figure out because all the docs and examples are deprecated - FUCK
	// Had to modify a lib file (BendModifier.js)
	var direction = new THREE.Vector3( 0, 0, -1 );
	var axis =  new THREE.Vector3( 0, 1, 0 );
	var angle = Math.PI / 2.5;
	var modifier = new THREE.BendModifier();
	modifier.set( direction, axis, angle ).modify( textMesh1.geometry );


	group.add( textMesh1 );

	// create a glowMesh to make the text glow like neon
	var glowMesh	= new THREEx.GeometricGlowMesh(textMesh1);
	group.add(glowMesh.object3d);

}


///////////////////////////////////\				  //////////////////////////////
//================================== end sub routines =============================
///////////////////////////////////////////////////////////////////////////////////


/*///////////////////////////////////////////////////////////////////////////////// 
	Updates frame by moving player, moving minimap camera, crashing player if they move above atmosphere or below floor, update animations, increment score and check for collisions
	Called by doFrame
	INPUT: none
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function updateForFrame() {

	//Move player backwards or forwards by their Z velocity
    player.translateZ(alpha.getSpeedZ());	

    //Move player up or down by their Y velocity
	player.translateY(alpha.getSpeedY());

	// move minimap camera on x,z axis according to player
	// minimap height stays constant right and captures from right bellow the atmosphere
	minimapCamera.position.set(player.position.x, minimapCamera.position.y, player.position.z);	

	// Put player on floor if they aren't already on it.
	if(!putOnFloor()){
		return;
	}

	//check for death by atmosphere (lasers) (height) + some leeway
	if(player.position.y > level.atmosphereHeight + 1){
		Crash();
		return;
	}

	// Slowly moving the camera back behind _alpha_
	if (resetCameraFlag){
		resetCameraPosition();
	}

	// Animate power-ups
	for(var i = 0; i < powerups.length; i++){
		powerups[i].animate();
	} 
	
//check if a power has been activated
	if(activePowerup != null) {
		if(activePowerup.getExpiration() < 0) {
			activePowerup.deactivatePower();
			activePowerup = null;
		} else {
			activePowerup.decrementExpiration();
		}
		
	}
	
	// animate collectibles
	for(var j = 0; j < collectibles.length; j++) {
		collectibles[j].animate();
	}

	// update model animation
	if(mixer) {
		mixer.update(0.02);
	}

	// camera can't got below floor
	if(new THREE.Vector3().setFromMatrixPosition(mainCamera.matrixWorld).y < worldMap.floorHeight + 0.1){
		mainCamera.position.y = worldMap.floorHeight + 1.1;
	}
	
	// Summon keyboard control lookups in one line.
	keyCheck(); 		

	//Collision
	collisions();
	if(alpha == null){
		return;
	}

	//animate josh sucks
	joshSucks.rotateY(Math.sin(Math.PI/6));

	// update cube map reflections. TODO: Only do this if the object is visible/ in 'range'
	//cubeCamera.update(renderer, scene);
	
	// Score update: TODO: ut in function and tidy up
	Score++;
 	document.getElementById("s1").innerHTML = "Score: " + Score;
 	document.getElementById("s2").innerHTML = "Lives: " + alpha.lives; // this will need to go in Crash function maybe

}


//<<<<<<<<<<<<<<<<<<<<<<<<<<<<< MOUSE AND KEYBOARD SUPPORT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>


// Event listeners for keydown and keyup events
window.addEventListener("keydown", keysPressed, false);
window.addEventListener("keyup", keysReleased, false);

// keyboard control taken from: http://www.johannes-raida.de/tutorials/three.js/tutorial07/tutorial07.htm
// multiple keypresses from: https://www.kirupa.com/html5/keyboard_events_in_javascript.htm

/*///////////////////////////////////////////////////////////////////////////////// 
	Keyboard key lookups:  Check if arrow, a,w,s,d and space keys are down using keys array
	Called by updateForFrame
	keycodes taken from: https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes	
	INPUT: none
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function keyCheck(){

	// Up Arrow or "w" - camera moves forwad = speed up
	if(keys[38] || keys[87]){ 
		alpha.incSpeedZ(-0.05);
	}
    // Down Arrow or "s" - camera moves back = speed down
    if(keys[40] || keys[83]){  
		alpha.incSpeedZ(0.05);
	}

    // a key: strafe left
    if (keys[65]) {     
        player.translateX(-0.2);
    }

    // d key: strafe right
    if (keys[68]) {     
        player.translateX(0.2);
    }

    // right arrow: turn right
    if (keys[39]) {     
        player.rotateY(-1 * Math.PI/180);
		minimapCamera.rotateZ(-1 * Math.PI/180);
    }

    // left arrow: turn left
    if (keys[37]) {     
        player.rotateY(Math.PI/180);
		minimapCamera.rotateZ(Math.PI/180) ;
    }

   // z key: fight gravity
   if (keys[90]) {
		if (!alpha.jumping) {			// Set limit on jumping
			alpha.incSpeedY(1);
		}
		alpha.jumping = true;
    }
}


/*///////////////////////////////////////////////////////////////////////////////// 
	This function gets called when a key is pressed
	Callback function for keydown event listener
	INPUT: keydown event e
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function keysPressed(e) {
	// "p" for pause and play           
	if(e.keyCode == 80){
		if(!animating){
			exitMenu();
			animating = true;
			requestAnimationFrame(doFrame);
		} else {
			animating = false;
			displayMenu(menusArr.pauseMenu);
		}
		return;
	}

	// F11 to enter and exit fullscreen
	if(e.keyCode == 122){
		if(!fullscreen){
			fullscreen = true;
			document.requestFullscreen();
		} else {
			fullscreen = false
			document.exitFullscreen();
		}
		return;
	}

	// F5 to refresh page
	if(e.keyCode == 116){
		window.location.reload(false); 
		return
	}
	
    // store an entry for every key pressed
    keys[e.keyCode] = true;
    // NB: prevent default browser behavior - disable during testing
    //e.preventDefault();
}

/*///////////////////////////////////////////////////////////////////////////////// 
	Callback function for keyup event listener
	INPUT: keyup event e
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function keysReleased(e) {
    // mark keys that were released
    keys[e.keyCode] = false;
    if (e.keyCode == 90) {
		alpha.jumping = false;
	}
}

 /*///////////////////////////////////////////////////////////////////////////////// 
	Uses THREE.OrbitControls from the graphics course to allow the user to rotate the view with the mouse
	Called by init and restartGame
	INPUT: none
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function installOrbitControls() {
    controls = new THREE.OrbitControls(mainCamera,canvas);
    controls.noPan = true; 
    controls.noZoom = true;
    controls.staticMoving = true;
    function move() {
        controls.update();
        if (! animating) {
            render();
        }
    }
    function down() {
        document.addEventListener("mousemove", move, false);
    }
    function up() {
        document.removeEventListener("mousemove", move, false);
    }
    function touch(event) {
        if (event.touches.length == 1) {
            move();
        }
    }
    document.addEventListener("mousedown", down, false);
    document.addEventListener("touchmove", touch, false);
}

// END OF MOUSE AND KEYBOARD FUNCTIONS


/*///////////////////////////////////////////////////////////////////////////////// 
	Drives the animation, called by system through requestAnimationFrame()
	Called by itself, exitMenu and keysPressed
	INPUT: none
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function doFrame() {
    if (animating) {
        updateForFrame();
        render();
		stats.update();
        requestAnimationFrame(doFrame);
    }
}


 /*/////////////////////////////////////////////////////////////////////////////////////
	Creates the renderer, container for stats, scene object, calls createWorld and installOrbitControls. Renders initial view of the scene
	Called by onload event
	INPUT: none
	OUTPUT: none
 //////////////////////////////////////////////////////////////////////////////////////*/
function init() {
    try {
		container = document.getElementById( 'container' );
		document.getElementById("s0").innerHTML = "Level: " + level.levelNum;
		renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.shadowMap.enabled = true;
		renderer.setScissorTest( true ); //important for minimap not to take control of entire screen even though it only occupies a corner
		renderer.setSize(window.innerWidth, window.innerHeight);
		//renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

		container.appendChild( renderer.domElement );

		stats = new Stats();
		container.appendChild( stats.dom );
    }
    catch (e) {
        document.getElementById("message").innerHTML="<b>Sorry, an error occurred:<br>" +
                e + "</b>";
        return;
    }
    createWorld();
    installOrbitControls();

	document.addEventListener("mousedown", function(){resetCameraFlag = false}, false);
	document.addEventListener("mouseup", function(){resetCameraFlag = true}, false);	
    render();
}

</script>

<!-- CSS -->
<style>
.container {
    position: relative;
    text-align: center;
    color: black;
}

.bottom-left {
    position: absolute;
    bottom: 8px;
    left: 16px;
}

.top-left {
    position: absolute;
    top: 8px;
    left: 16px;
}

.top-right {
    position: absolute;
    top: 8px;
    right: 16px;
}

.bottom-right {
    position: absolute;
    bottom: 8px;
    right: 16px;
}

.centered {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.text-block {
    position: absolute;
    bottom: 20px;
    right: 20px;
    background-color:rgba(192,192,192,0.5);
    color: white;
    padding-left: 20px;
    padding-right: 20px;
}

</style>


</head>
<body onload="init()">


	<noscript>
   		<p style="color: #AA0000; font-weight: bold">Sorry, but this page requires JavaScript!</p>
	</noscript>

	<p style="color:#AA0000; font-weight: bold" id="message"> </p>
 	<div class="container">
		<div id="container"></div>
	  	<div class="text-block">
	    	<h4>Stats</h4>
	    	<p id="s0"></p>
	    	<p id="s1">Score: NaN </p>
	    	<p id="s2">Lives: - / - </p>
	    </div>
	</div>

</body>
</html>
