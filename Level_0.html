<!DOCTYPE html>
<head>
<meta charset="UTF-8">
<title>_alpha_</title>
<script src="src\js\three.js"></script>
<script src="src\js\OrbitControls.js"></script>
<script src="src\js\libs\stats.min.js"></script>
<script src="src\js\OBJLoader.js"></script>
<script src="src\js\MTLLoader.js"></script>

<script src="src\alpha.js"></script>
<script src="src\map.js"></script>
<script src="src\powerup.js"></script>
<script src="src\collectible.js"></script>

<script>

"use strict";

//Globals
var WORLD_WIDTH = 5000;
var WORLD_DEPTH = 5000;
var ATMOSPHERE_HEIGHT = 100;
var ALPHA_CAMERA_DISTANCE = 20;

var canvas, renderer, scene, camera; // Standard three.js requirements.

var container, stats;

var controls;  // An OrbitControls object that is used to implement
               // rotation of the scene using the mouse.  (It actually rotates
               // the camera around the scene.)

var fullscreen = false;
var animating = false;  // Set to true when an animation is in progress.
var frameNumber = 0;  // Frame number is advanced by 1 for each frame while animating.

var player = new THREE.Object3D();

var keys = []; //records current keys being pressed

var resetCameraFlag = false //flag to reset the camera position to original position

var jumping = false;	//whether player is jumping or not

var alpha;	// player stats tracking + model  object

var gameOver = false; //updates to true when lives == 0

var worldMap; // make global so it can be accessed by collision function

var powerups = [];	

var collideMeshArray = []; // array to store  all collidable mesh's (buildings + items)

var alpha;
var powerups = [];			// items providing certain powerups or "boosts" to the player for a short time when picked up
var collectibles = [];			// the items that the player needs to collect in order to progress to the next level
//var collectiblesLeft = 0;			// the number of collectibles left to collect. when this reaches zero, go to next level
var mixer = null;  // The object that animates the model, of type THREE.AnimationMixer

var minimapCamera, minimapWidth = window.innerHeight/5, minimapHeight = window.innerHeight/5; //

var worldMap;

/**
 *  The render function draws the scene.
 */
function render() {
	var w = window.innerWidth, h = window.innerHeight;
	renderer.setSize(w,h);

	// Render main camera on entire screen
	renderer.setViewport( 0, 0, w, h );
	renderer.setScissor( 0, 0, w, h );
	renderer.setScissorTest( true );
	camera.aspect = w / h;
	camera.updateProjectionMatrix();
    renderer.render(scene, camera);

	// Render minimap camera in bottom left corner
	renderer.setViewport( w - minimapWidth - 50, 20, minimapWidth, minimapHeight );
	renderer.setScissor( w - minimapWidth - 50, 20, minimapWidth, minimapHeight );
	renderer.setScissorTest( true ); //important for minimap not to take control of entire screen even though it only occupies a corner
	minimapCamera.aspect = w / h;
	minimapCamera.updateProjectionMatrix();
	renderer.render( scene, minimapCamera );
}


/**
 * This function is called by the init() method to create the world. 
 */
function createWorld() {
    
    renderer.setClearColor("black"); // Background color for scene.
    scene = new THREE.Scene();
    
    // ------------------- Make a camera with viewpoint light ----------------------
    
    camera = new THREE.PerspectiveCamera(30, window.innerWidth/window.innerHeight, 0.1, 10000);
    camera.position.z = ALPHA_CAMERA_DISTANCE;
    var light;  // A light shining from the direction of the camera; moves with the camera.
    light = new THREE.DirectionalLight();
    light.position.set(0,50,0);
    camera.add(light);
    player.add(camera);
    scene.add(player);
    
	//---------------------- Minimap ----------------------------------------------
	minimapCamera = new THREE.OrthographicCamera(
	    window.innerHeight / -5,						// Left
		window.innerHeight / 5,							// Right
    	window.innerHeight / 5,							// Top
    	window.innerHeight / -5,						// Bottom
    	-1 * ATMOSPHERE_HEIGHT + 0.001,					// Near 
    	10000 );           								// Far 
	minimapCamera.up = new THREE.Vector3(0,0,-1);
	minimapCamera.lookAt( new THREE.Vector3(0,-1,0) );

	scene.add(minimapCamera);



    //---------------------------------- CREATE THE WORLD -------------------------------------------
    

	worldMap = new Map(WORLD_WIDTH, WORLD_DEPTH, ATMOSPHERE_HEIGHT, "textures/floor.jpg", "textures/skyboxes/dawnmountain/") //width, height, atmosphereHight, textureURL, skyboxDirectory
	scene.add(worldMap.floor);
	scene.add(worldMap.skybox);
	scene.add(worldMap.atmosphere);	

	//add buildings to scene
	worldMap.createBuildings(1/4); //map-buildings ratio is 1/4
	for (var i = 0; i < worldMap.buildings.length; i++){
		scene.add(worldMap.buildings[i]);
	}
	
	//----------------------------------- CREATE THE PLAYER --------------------------------------------

// alpha is created by model_loader function and added to player
	
	var loader = new THREE.JSONLoader();					// create loader for .js models
	loader.load("models/stork.js", model_loader);		// load model and call model_loader
	
	var gun = new Powerup("gun");	// add a gun powerup
	gun.position.set(3,1,3);
	powerups.push(gun);

	var inv = new Powerup("invisible");	// add invisibility powerup
	inv.position.set(10,1,10);
	powerups.push(inv);

	var grav = new Powerup("gravity");	// add a gravity powerup
	grav.position.set(-10,1,12);
	powerups.push(grav);

	for(var i = 0; i < powerups.length; i++){
		scene.add(powerups[i]);
	} 
	
	var collectible0 = new Collectible(
		new THREE.CylinderGeometry(1,0.5,1,32),
		new THREE.MeshPhongMaterial({color: 0xff00ff})
	);
	collectible0.position.set(-3,1,3);
	collectibles.push(collectible0);
	
	var collectible1 = new Collectible(
		new THREE.CylinderGeometry(1,0.5,1,32),
		new THREE.MeshPhongMaterial({color: 0x00ffff})
	);
	collectible1.position.set(4,1,-4);
	collectibles.push(collectible1);
	
	for (var j = 0; j < collectibles.length; j++) {
		scene.add(collectibles[j]);
	}

} // end function createWorld()




/*<<<<<<<<<<<<<<<<<<<<<< C U S T O M 	S U B   R O U T I N E S >>>>>>>>>>>>>>>>>>>>>>>>>>>
			                                 |_
			                           _____|~ |____
			                          (  --         ~~~~--_,
			                           ~~~~~~~~~~~~~~~~~~~'`  

*/

/*///////////////////////////////////////////////////////////////////////////////// 
Reset the camera's to be behind the player (chase cam), after viewing the world.
//////////////////////////////////////////////////////////////////////////////////*/

function resetCameraPosition(){
	var cameraRotationSpeed = 0.1;
	camera.translateX((alpha.position.x - camera.position.x) * cameraRotationSpeed);
	camera.translateY((alpha.position.y - camera.position.y) * cameraRotationSpeed);
	camera.translateZ((alpha.position.z + ALPHA_CAMERA_DISTANCE - camera.position.z) * cameraRotationSpeed);
	camera.lookAt(alpha.position);

	if(Math.abs(alpha.position.x - camera.position.x) <= 0.01 &&
		Math.abs(alpha.position.y - camera.position.y <= 0.01) &&
		Math.abs(alpha.position.z + ALPHA_CAMERA_DISTANCE - camera.position.z <= 0.01)){
		
		resetCameraFlag = false;
	}
}



/*//////////////////////////////////////////////////////////////////////////
 Keyboard key lookups:  Check arrow, a,w,s,d and space keys
///////////////////////////////////////////////////////////////////////////*/

window.addEventListener("keydown", keysPressed, false);
window.addEventListener("keyup", keysReleased, false);

function key_check(){
	//keycodes taken from: https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes	

	// Up Arrow or "w" - camera moves forwad = speed up
	if(keys[38] || keys[87]){ 
		alpha.incSpeedZ(-0.05);
	}
    // Down Arrow or "s" - camera moves back = speed down
    if(keys[40] || keys[83]){  
		alpha.incSpeedZ(0.05);
	}

    // a key: strafe left
    if (keys[65]) {     
        player.translateX(-0.2);
    }

    // d key: strafe right
    if (keys[68]) {     
        player.translateX(0.2);
    }

    // right arrow: turn right
    if (keys[39]) {     
        player.rotation.y -= 0.03;
    }

    // left arrow: turn left
    if (keys[37]) {     
        player.rotation.y += 0.03;
    }

   // space key: fight gravity
   if (keys[90]) {     
		if (!jumping) {			// Set limit on jumping
			alpha.incSpeedY(1);
		}
		jumping = true;
    }
}

// This function gets called when a key is pressed
function keysPressed(e) {
	// "p" for pause and play           
	if(e.keyCode == 80){
		if(!animating){
			animating = true;
			requestAnimationFrame(doFrame);
		} else {
			animating = false;
		}
		return;
	}

	// F11 to enter and exit fullscreen
	if(e.keyCode == 122){
		if(!fullscreen){
			fullscreen = true;
			document.requestFullscreen();
		} else {
			fullscreen = false
			document.exitFullscreen();
		}
		return;
	}

	// F5 to refresh page
	if(e.keyCode == 116){
		window.location.reload(false); 
		return
	}
	
    // store an entry for every key pressed
    keys[e.keyCode] = true;
        // NB: prevent default browser behavior - disable during testing
        //e.preventDefault();
}

function keysReleased(e) {
    // mark keys that were released
    keys[e.keyCode] = false;
    if (e.keyCode == 90) {
		jumping = false;
	}
}


/*//////////////////////////////////////////////////////////////////////////
Put player on the floor
///////////////////////////////////////////////////////////////////////////*/
function put_on_floor() {
	if(player.position.y > -2 + alpha.getRadius()) {	//check if player has reached the "floor"
		alpha.incSpeedY(-0.01);				//if they have not, reduce speed (gravity)
	} else {						//if they have, stop reducing speed and set position to the ground, set Y speed to zero
		alpha.setSpeedY(0);
		player.position.y = -2 + alpha.getRadius();
	}	
}



/*//////////////////////////////////////////////////////////////////////////
Model Loader
///////////////////////////////////////////////////////////////////////////*/

function model_loader(geometry, materials) {

	var material = new THREE.MeshLambertMaterial( {
        vertexColors: THREE.FaceColors,  	// use colors from the geometry
        morphTargets: true							// for animation
    });
	
	alpha = new Alpha(geometry,material, 1);	// create alpha object
	
// TRANSFORMS

	alpha.scale.set(0.05,0.05,0.05);
	alpha.position.set(0,-2,0);
	alpha.rotateY(Math.PI);
	
	player.add(alpha);				// add alpha to player
	
// ANIMATION STUFF
	
	mixer = new THREE.AnimationMixer( alpha );
	var clip = THREE.AnimationClip.CreateFromMorphTargetSequence( 'motion', geometry.morphTargets, 30 );
    var animationAction = mixer.clipAction(clip);
    animationAction.setDuration(1);
    animationAction.play(); 
	render();
}




/*//////////////////////////////////////////////////////////////////////////
Crash: Explosion, respawn from crash site, decrement lives, game over
///////////////////////////////////////////////////////////////////////////*/
function Crash() {
	// Update Alpha stats
	alpha.lives -= 1;
	// if no more lives, game over
	if (alpha.lives == 0){
		gameOver = true;
		window.alert("G A M E    O V E R");
		//do other stuff
	}else{
	// TODO : Crash animation, respawn
		animating = false;
	// respawning:
	// player.position = legal position
	// 
	}

}

/*//////////////////////////////////////////////////////////////////////////
Collisions!
///////////////////////////////////////////////////////////////////////////*/

//This must be called in updateFrame
// credit to Lee Stemkoski for his tutorial
// insert link to page


function  collissions() {
	var originPoint = player.position.clone();	// players position

	for (var vertexIndex = 0; vertexIndex < alpha.geometry.vertices.length; vertexIndex++)
		{		
			var localVertex = alpha.geometry.vertices[vertexIndex].clone();
			var globalVertex = localVertex.applyMatrix4( alpha.matrix );
			var directionVector = globalVertex.sub( alpha.position );
			
			var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
			
			// Check building collisions
			var BuildingCollisionResults = ray.intersectObjects( worldMap.buildings );
			
			// Check Powerups[] collisions
				// TODO
			var PowerupsCollisionResults = ray.intersectObjects(powerups);
			
			var CollectibleCollisionResults = ray.intersectObjects(collectibles);

			if ( BuildingCollisionResults.length > 0 && BuildingCollisionResults[0].distance < directionVector.length() - 1){ // TODO: adjust this offset (-1 currently)
				console.log("hit");
				Crash();
			}
			//TODO: if powerup 0,1,2 do stuff to alpha.stats, delete power up from powerupsarray,and remove from scene (maybe with a fancy animation)
			if (PowerupsCollisionResults.length > 0 && PowerupsCollisionResults[0].distance < directionVector.length()){
				//Check what type of powerup it was
				if(PowerupsCollisionResults[0].object.type == powerupTypes["gun"]){
					console.log("Gun"); //TODO: update alpha stats
				}else if(PowerupsCollisionResults[0].object.type == powerupTypes["invisible"]){
					console.log("Invisible"); //TODO: update alpha stats
				}else if(PowerupsCollisionResults[0].object.type == powerupTypes["gravity"]){
					console.log("Gravity"); //TODO: update alpha stats
				}
				
				powerups.splice(powerups.indexOf (PowerupsCollisionResults[0].object), 1 );
				scene.remove(PowerupsCollisionResults[0].object);
			}
			
			if ( CollectibleCollisionResults.length > 0 && CollectibleCollisionResults[0].distance < directionVector.length() ){ 
				console.log(collectibles.indexOf (CollectibleCollisionResults[0].object) );
				collectibles.splice(collectibles.indexOf (CollectibleCollisionResults[0].object), 1 );
				scene.remove(CollectibleCollisionResults[0].object);
			}

		}// end for loop	

} // end collision function







///////////////////////////////////\				  //////////////////////////////
//================================== end sub routines =============================
///////////////////////////////////////////////////////////////////////////////////
/**
 *  This function is called once for each frame of the animation, before
 *  the render() function is called for that frame.  It updates any
 *  animated properties.  The value of the global variable frameNumber
 *  is incrementd 1 before this function is called.
 */
function updateForFrame() {
	//Move player backwards or forwards by their Z velocity
    player.translateZ(alpha.getSpeedZ());	

    //Move player up or down by their Y velocity
	player.translateY(alpha.getSpeedY());

	// move minimap camera on x,z axis according to player
	// minimap height stays constant right and captures from right bellow the atmosphere
	minimapCamera.position.set(player.position.x, minimapCamera.position.y, player.position.z);	

	// Put player on floor if they aren't already on it.
	// TODO:Might need to update this for dying
	put_on_floor();

	// Slowly moving the camera back behind _alpha_
	if (resetCameraFlag){
		resetCameraPosition();
	}

	// Animate power-ups
	for(var i = 0; i < powerups.length; i++){
		powerups[i].animate();
	} 
	
	for(var j = 0; j < collectibles.length; j++) {
		collectibles[j].animate();
	}

	// update model animation
	if(mixer) {
		mixer.update(0.02);
	}

	// camera can't got below floor
	if(camera.position.y < worldMap.floorHeight + 1.1){
		camera.position.y = worldMap.floorHeight + 1.1;
	}
	

	// Summon keyboard control lookups in one line.
	key_check(); 		


	//Collision
	collissions();

	
}


/* ---------------------------- MOUSE AND ANIMATION SUPPORT ------------------

/**
 *  This page uses THREE.OrbitControls to let the user use the mouse to rotate
 *  the view.  OrbitControls are designed to be used during an animation, where
 *  the rotation is updated as part of preparing for the next frame.  The scene
 *  is not automatically updated just because the user drags the mouse.  To get
 *  the rotation to work without animation, I add another mouse listener to the
 *  canvas, just to call the render() function when the user drags the mouse.
 *  The same thing holds for touch events -- I call render for any mouse move
 *  event with one touch.
 */
function installOrbitControls() {
    controls = new THREE.OrbitControls(camera,canvas);
    controls.noPan = true; 
    controls.noZoom = true;
    controls.staticMoving = true;
    function move() {
        controls.update();
        if (! animating) {
            render();
        }
    }
    function down() {
        document.addEventListener("mousemove", move, false);
    }
    function up() {
        document.removeEventListener("mousemove", move, false);
    }
    function touch(event) {
        if (event.touches.length == 1) {
            move();
        }
    }
    document.addEventListener("mousedown", down, false);
    document.addEventListener("touchmove", touch, false);
}


// It determines _alpha_'s movements ("Space" with arrow keys or WASD). 
/*  Drives the animation, called by system through requestAnimationFrame() */
function doFrame() {
    if (animating) {
        frameNumber++;
        updateForFrame();
        render();
		stats.update();
        requestAnimationFrame(doFrame);
    }
}


/*----------------------------- INITIALIZATION ----------------------------------------

/**
 *  This function is called by the onload event so it will run after the
 *  page has loaded.  It creates the renderer, canvas, and scene objects,
 *  calls createWorld() to add objects to the scene, and renders the
 *  initial view of the scene.  If an error occurs, it is reported.
 */
function init() {
    try {
		container = document.getElementById( 'container' );
		renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		container.appendChild( renderer.domElement );

		stats = new Stats();
		container.appendChild( stats.dom );

    }
    catch (e) {
        document.getElementById("message").innerHTML="<b>Sorry, an error occurred:<br>" +
                e + "</b>";
        return;
    }
    createWorld();
    installOrbitControls();

	// keyboard controls
	// taken from: http://www.johannes-raida.de/tutorials/three.js/tutorial07/tutorial07.htm
	// multiple keypresses from: https://www.kirupa.com/html5/keyboard_events_in_javascript.htm
	document.addEventListener("mousedown", function(){resetCameraFlag = false}, false);
	document.addEventListener("mouseup", function(){resetCameraFlag = true}, false);	

    render();
}

</script>
</head>
<body onload="init()">
	<noscript>
   		<p style="color: #AA0000; font-weight: bold">Sorry, but this page requires JavaScript!</p>
	</noscript>

	<p style="color:#AA0000; font-weight: bold" id="message"> </p>

	<div id="container"></div>

</body>
</html>
ads a Wavefront .mtl file specifying materials
 *
 * @author angelxuanchang
 */

THREE.MTLLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.MTLLoader.prototype = {

	constructor: THREE.MTLLoader,

	/**
	 * Loads and parses a MTL asset from a URL.
	 *
	 * @param {String} url - URL to the MTL file.
	 * @param {Function} [onLoad] - Callback invoked with the loaded object.
	 * @param {Function} [onProgress] - Callback for download progress.
	 * @param {Function} [onError] - Callback for download errors.
	 *
	 * @see setPath setTexturePath
	 *
	 * @note In order for relative texture references to resolve correctly
	 * you must call setPath and/or setTexturePath explicitly prior to load.
	 */
	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.FileLoader( this.manager );
		loader.setPath( this.path );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( text ) );

		}, onProgress, onError );

	},

	/**
	 * Set base path for resolving references.
	 * If set this path will be prepended to each loaded and found reference.
	 *
	 * @see setTexturePath
	 * @param {String} path
	 * @return {THREE.MTLLoader}
	 *
	 * @example
	 *     mtlLoader.setPath( 'assets/obj/' );
	 *     mtlLoader.load( 'my.mtl', ... );
	 */
	setPath: function ( path ) {

		this.path = path;
		return this;

	},

	/**
	 * Set base path for resolving texture references.
	 * If set this path will be prepended found texture reference.
	 * If not set and setPath is, it will be used as texture base path.
	 *
	 * @see setPath
	 * @param {String} path
	 * @return {THREE.MTLLoader}
	 *
	 * @example
	 *     mtlLoader.setPath( 'assets/obj/' );
	 *     mtlLoader.setTexturePath( 'assets/textures/' );
	 *     mtlLoader.load( 'my.mtl', ... );
	 */
	setTexturePath: function ( path ) {

		this.texturePath = path;
		return this;

	},

	setBaseUrl: function ( path ) {

		console.warn( 'THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead.' );

		return this.setTexturePath( path );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;
		return this;

	},

	setMaterialOptions: function ( value ) {

		this.materialOptions = value;
		return this;

	},

	/**
	 * Parses a MTL file.
	 *
	 * @param {String} text - Content of MTL file
	 * @return {THREE.MTLLoader.MaterialCreator}
	 *
	 * @see setPath setTexturePath
	 *
	 * @note In order for relative texture references to resolve correctly
	 * you must call setPath and/or setTexturePath explicitly prior to parse.
	 */
	parse: function ( text ) {

		var lines = text.split( '\n' );
		var info = {};
		var delimiter_pattern = /\s+/;
		var materialsInfo = {};

		for ( var i = 0; i < lines.length; i ++ ) {

			var line = lines[ i ];
			line = line.trim();

			if ( line.length === 0 || line.charAt( 0 ) === '#' ) {

				// Blank line or comment ignore
				continue;

			}

			var pos = line.indexOf( ' ' );

			var key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;
			key = key.toLowerCase();

			var value = ( pos >= 0 ) ? line.substring( pos + 1 ) : '';
			value = value.trim();

			if ( key === 'newmtl' ) {

				// New material

				info = { name: value };
				materialsInfo[ value ] = info;

			} else if ( info ) {

				if ( key === 'ka' || key === 'kd' || key === 'ks' ) {

					var ss = value.split( delimiter_pattern, 3 );
					info[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];

				} else {

					info[ key ] = value;

				}

			}

		}

		var materialCreator = new THREE.MTLLoader.MaterialCreator( this.texturePath || this.path, this.materialOptions );
		materialCreator.setCrossOrigin( this.crossOrigin );
		materialCreator.setManager( this.manager );
		materialCreator.setMaterials( materialsInfo );
		return materialCreator;

	}

};

/**
 * Create a new THREE-MTLLoader.MaterialCreator
 * @param baseUrl - Url relative to which textures are loaded
 * @param options - Set of options on how to construct the materials
 *                  side: Which side to apply the material
 *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide
 *                  wrap: What type of wrapping to apply for textures
 *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping
 *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255
 *                                Default: false, assumed to be already normalized
 *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's
 *                                  Default: false
 * @constructor
 */

THREE.MTLLoader.MaterialCreator = function ( baseUrl, options ) {

	this.baseUrl = baseUrl || '';
	this.options = options;
	this.materialsInfo = {};
	this.materials = {};
	this.materialsArray = [];
	this.nameLookup = {};

	this.side = ( this.options && this.options.side ) ? this.options.side : THREE.FrontSide;
	this.wrap = ( this.options && this.options.wrap ) ? this.options.wrap : THREE.RepeatWrapping;

};

THREE.MTLLoader.MaterialCreator.prototype = {

	constructor: THREE.MTLLoader.MaterialCreator,

	crossOrigin: 'Anonymous',

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	setManager: function ( value ) {

		this.manager = value;

	},

	setMaterials: function ( materialsInfo ) {

		this.materialsInfo = this.convert( materialsInfo );
		this.materials = {};
		this.materialsArray = [];
		this.nameLookup = {};

	},

	convert: function ( materialsInfo ) {

		if ( ! this.options ) return materialsInfo;

		var converted = {};

		for ( var mn in materialsInfo ) {

			// Convert materials info into normalized form based on options

			var mat = materialsInfo[ mn ];

			var covmat = {};

			converted[ mn ] = covmat;

			for ( var prop in mat ) {

				var save = true;
				var value = mat[ prop ];
				var lprop = prop.toLowerCase();

				switch ( lprop ) {

					case 'kd':
					case 'ka':
					case 'ks':

						// Diffuse color (color under white light) using RGB values

						if ( this.options && this.options.normalizeRGB ) {

							value = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];

						}

						if ( this.options && this.options.ignoreZeroRGBs ) {

							if ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 2 ] === 0 ) {

								// ignore

								save = false;

							}

						}

						break;

					default:

						break;

				}

				if ( save ) {

					covmat[ lprop ] = value;

				}

			}

		}

		return converted;

	},

	preload: function () {

		for ( var mn in this.materialsInfo ) {

			this.create( mn );

		}

	},

	getIndex: function ( materialName ) {

		return this.nameLookup[ materialName ];

	},

	getAsArray: function () {

		var index = 0;

		for ( var mn in this.materialsInfo ) {

			this.materialsArray[ index ] = this.create( mn );
			this.nameLookup[ mn ] = index;
			index ++;

		}

		return this.materialsArray;

	},

	create: function ( materialName ) {

		if ( this.materials[ materialName ] === undefined ) {

			this.createMaterial_( materialName );

		}

		return this.materials[ materialName ];

	},

	createMaterial_: function ( materialName ) {

		// Create material

		var scope = this;
		var mat = this.materialsInfo[ materialName ];
		var params = {

			name: materialName,
			side: this.side

		};

		function resolveURL( baseUrl, url ) {

			if ( typeof url !== 'string' || url === '' )
				return '';

			// Absolute URL
			if ( /^https?:\/\//i.test( url ) ) return url;

			return baseUrl + url;

		}

		function setMapForType( mapType, value ) {

			if ( params[ mapType ] ) return; // Keep the first encountered texture

			var texParams = scope.getTextureParams( value, params );
			var map = scope.loadTexture( resolveURL( scope.baseUrl, texParams.url ) );

			map.repeat.copy( texParams.scale );
			map.offset.copy( texParams.offset );

			map.wrapS = scope.wrap;
			map.wrapT = scope.wrap;

			params[ mapType ] = map;

		}

		for ( var prop in mat ) {

			var value = mat[ prop ];
			var n;

			if ( value === '' ) continue;

			switch ( prop.toLowerCase() ) {

				// Ns is material specular exponent

				case 'kd':

					// Diffuse color (color under white light) using RGB values

					params.color = new THREE.Color().fromArray( value );

					break;

				case 'ks':

					// Specular color (color when light is reflected from shiny surface) using RGB values
					params.specular = new THREE.Color().fromArray( value );

					break;

				case 'map_kd':

					// Diffuse texture map

					setMapForType( "map", value );

					break;

				case 'map_ks':

					// Specular map

					setMapForType( "specularMap", value );

					break;

				case 'norm':

					setMapForType( "normalMap", value );

					break;

				case 'map_bump':
				case 'bump':

					// Bump texture map

					setMapForType( "bumpMap", value );

					break;

				case 'ns':

					// The specular exponent (defines the focus of the specular highlight)
					// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.

					params.shininess = parseFloat( value );

					break;

				case 'd':
					n = parseFloat( value );

					if ( n < 1 ) {

						params.opacity = n;
						params.transparent = true;

					}

					break;

				case 'tr':
					n = parseFloat( value );

					if ( this.options && this.options.invertTrProperty ) n = 1 - n;

					if ( n > 0 ) {

						params.opacity = 1 - n;
						params.transparent = true;

					}

					break;

				default:
					break;

			}

		}

		this.materials[ materialName ] = new THREE.MeshPhongMaterial( params );
		return this.materials[ materialName ];

	},

	getTextureParams: function ( value, matParams ) {

		var texParams = {

			scale: new THREE.Vector2( 1, 1 ),
			offset: new THREE.Vector2( 0, 0 )

		 };

		var items = value.split( /\s+/ );
		var pos;

		pos = items.indexOf( '-bm' );

		if ( pos >= 0 ) {

			matParams.bumpScale = parseFloat( items[ pos + 1 ] );
			items.splice( pos, 2 );

		}

		pos = items.indexOf( '-s' );

		if ( pos >= 0 ) {

			texParams.scale.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );
			items.splice( pos, 4 ); // we expect 3 parameters here!

		}

		pos = items.indexOf( '-o' );

		if ( pos >= 0 ) {

			texParams.offset.set( parseFloat( items[ pos + 1 ] ), parseFloat( items[ pos + 2 ] ) );
			items.splice( pos, 4 ); // we expect 3 parameters here!

		}

		texParams.url = items.join( ' ' ).trim();
		return texParams;

	},

	loadTexture: function ( url, mapping, onLoad, onProgress, onError ) {

		var texture;
		var loader = THREE.Loader.Handlers.get( url );
		var manager = ( this.manager !== undefined ) ? this.manager : THREE.DefaultLoadingManager;

		if ( loader === null ) {

			loader = new THREE.TextureLoader( manager );

		}

		if ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );
		texture = loader.load( url, onLoad, onProgress, onError );

		if ( mapping !== undefined ) texture.mapping = mapping;

		return texture;

	}

};

